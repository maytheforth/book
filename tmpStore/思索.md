语言选型的时候，应该先考虑它的生态圈，然后考虑开发效率和运行效率的平衡。

要研究mysql在海量数据下如何优化，首先应该创造出海量的数据。

<https://www.cnblogs.com/thammer/p/7103065.html>

signal(SIGCHLD, SIG_DFL);

signal(SIGPIPE, SIG_IGN);

SIGINT 与ctrl+c相关联

linux守护进程

```c++
int main()
{
   int i = 0;
   i++;
   cout << "hello world" << endl;
}
```

根据加-O2编译出来的程序，不会预留int大小的内存空间，更不会对内存中的数字加1.他只会输出“hello world”到标准输出中。

as-if-serial 语义：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不会改变。编译器和处理器不会对存在数据依赖关系的操作做重排序。     volatile修饰的变量，顺序和内容是不能改变的。

cpu缓存一致性协议 MESI

```c++
#include<stdio.h>
int main()
{
	volatile int i = 10;
	int a = i;
	printf("a=%d\n", a);
    // 下面汇编语句的作用就是改变内存中i的值，但是又不让编译器知道。
	__asm {mov dword ptr [ebp-4],20h}
	int b = i;
	printf("b=%d", b);
	getchar();
	return 0;
}
```

加入o2优化，或者不加入o2优化，结果时不同的。

优化时，由于编译器发现两个从i读数据的代码之间没有对i进行过操作，它会自动把上次读的数据放在b中，而不是重新从内存中读。

在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。

CAS(比较和交换，Compare and swap) 是一种有名的无锁算法。CAS的语义是"我认为V的值应该为A,如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少"。CAS是项乐观锁技术。当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并且可以再次尝试。

```
__asm
{
  mov ecx,Destination;
  mov edx,Exchange;
  mov eax,Comperand;
  lock cmpxchg[ecx],edx;
}
```

**CMPXCHG:** 比较交换指令，第一操作数先和AL/AX/EAX比较，如果相等ZF置1，第二操作数赋给第一操作数，否则ZF清0，第一操作数赋给AL/AX/EAX。多处理器安全，在80486及以上cpu中支持。

CAS和ABA问题(掉包问题):

​      CAS操作容易导致ABA问题，即在CAS修改数据a之前，数据a可能被多个线程修改过了，只不过回到了最初的值,难以确保此间发生了什么，可以引入版本号来解决这个问题。



operator const char* () const    是自动类型转化函数的定义。

```c++
#include<iostream>
using namespace std;
class MyInt
{
public:
    MyInt(int x): elem(x) {}
    ~MyInt() {}
    operator int() const;
private:
    int elem;
};
MyInt::operator int() const
{
   return elem;
}
int main()
{
   int a = 0;
   MyInt obj(5);
   a = obj;
   cout << a << endl;
   return 0;
}
```



gdb attach pid

epoll收取到包之后，封装成任务，以轮询的方式将任务push到线程的任务队列中，然后线程从队列中pop出任务。

perf  top  -p                             perf record

kafka 消息队列















>**1.限制动态分配内存**
>
>**相关的知识背景：**glibc默认的malloc背后有复杂的算法，当堆空间不足时会调用sbrk()，当分配内存很大时会调用mmap()，这些都是系统调用，似乎会比较慢，而且新分配的内存被first touch时也要过很久才能准备好。
>
>**可取的做法：**尽量使用vector或者array（初始化时分配足够的空间，之后每次使用都从里面取出来用）。尽量使用内存池。如果需要二叉树或者哈希表，尽量使用侵入式容器（boost::intrusive）。



>**2.使用轮询，尽量避免阻塞**
>
>**相关的知识背景：**上下文切换是非常耗时的，其中固定的消耗包括（cpu流水线被冲掉、各种寄存器需要被保存和恢复、内核中的调度算法要被执行），此外，缓存很有可能出现大量miss，这属于不固定的时间消耗。
>
>**可取的做法：**使用带有内核bypass功能的网卡。每个进程或者线程都独占一个cpu核【isolcpus和irqbalance的细节见注释3】，并且不停地轮询，用以保证快速响应。尽量避免任何可能导致阻塞的事件（如mutex），某些注定很慢的活动（比如把log写到磁盘上）应该被独立出来放到别的cpu上，不能影响主线程。



>**3.使用共享内存作为唯一的IPC机制**
>
>**相关的知识背景：**共享内存只有在初始化的时候有一些系统调用，之后就可以像访问正常内存一样使用了。其他IPC机制（管道、消息队列、套接字）则是每次传输数据时都有系统调用，并且每次传输的数据都经历多次拷贝。因此共享内存是最快的IPC机制。
>
>**可取的做法：**使用共享内存作为唯一的IPC机制。当然，可能需要手动实现一些东西来保证共享的数据在多进程下是安全，我们是自己实现了无锁内存池、无锁队列和顺序锁【关于seqlock的疑点见注释1】。



>**4.传递消息时使用无锁队列**
>
>**相关的知识背景：**我只关注基于数组的无锁队列，其中：spsc队列是wait-free的，不论是入队出队都可以在确定的步数之内完成，而且实现时只需要基本的原子操作【为什么这很重要见注释7】；mpmc队列的实现方式则多种多样，但都会稍微慢一点，因为它们需要用一些比较重的原子操作（CAS或者FAA），而且有时它们需要等待一段不确定的时间直到另一个线程完成相应操作；另外，还有一种multi-observer的『广播队列』，多个读者可以收到同一条消息广播，这种队列也有sp和mp类型的，可以检查或者不检查overwrite；最后，还有一种队列允许存储不定长的消息。
>
>**可取的做法：**总的来说，应该避免使用mp类型的队列，举例：如果要用mpsc队列，可以使用多个spsc来达成目的，并不需要mp队列；同理，如果是消息广播，也可以使用多个sp队列来取代一个mp队列；如果广播时observer只想订阅一部分消息，那么可以用多个spsc+有计数功能的内存池【具体做法见注释2】；如果要求多个观察者看到多个生产者的消息，并且顺序一致，那只能用mp队列了。总结一下，mp类型的队列应该尽量避免，因为当多个生产者同时抢占队列的时候，延时会线性增长。



>**5.考虑缓存对速度的影响**
>
>**相关的背景知识：**现在的机器内存是十分充足的，但是缓存还是很小，因此所有节省内存的技巧都还有用武之地。
>
>**可取的做法：**尽量让可能被同时使用的数据挨在一起；减少指针链接（比如用array取代vector，因为链接指向的地方可能不在缓存里）；尽量节省内存（比如用unique_ptr<Data[]>取代vector<Data>，比如成员变量按照从大到小排序，比如能用int8的地方就不用int16）；指定cpu affinity时考虑LLC缓存（同核的两个超线程是共享L1，同cpu的两个核是共享L3，不同NUMA核是通过QPI总线）；会被多个核同时读写的数据按照缓存行对齐（避免false sharing）。



































